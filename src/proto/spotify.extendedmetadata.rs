// This file is @generated by prost-build.
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entity {
    #[prost(oneof = "entity::Entity", tags = "1, 2, 3, 4, 5, 6")]
    pub entity: ::core::option::Option<entity::Entity>,
}
/// Nested message and enum types in `Entity`.
pub mod entity {
    #[derive(serde::Deserialize, serde::Serialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Entity {
        #[prost(message, tag = "1")]
        Artist(super::Artist),
        #[prost(message, tag = "2")]
        Album(super::Album),
        #[prost(message, tag = "3")]
        Track(super::Track),
        #[prost(message, tag = "4")]
        Show(super::Show),
        #[prost(message, tag = "5")]
        Episode(super::Episode),
        #[prost(message, tag = "6")]
        AlbumGroup(super::AlbumGroup),
    }
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocalizedString {
    #[prost(string, optional, tag = "1")]
    pub language: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Artist {
    /// \[mandatory\]
    ///
    /// 16 bytes
    #[prost(bytes = "vec", optional, tag = "1")]
    pub gid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// \[mandatory\]
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// 0-100
    #[prost(sint32, optional, tag = "3")]
    pub popularity: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "4")]
    pub top_track: ::prost::alloc::vec::Vec<TopTracks>,
    #[prost(message, repeated, tag = "5")]
    pub album_group: ::prost::alloc::vec::Vec<AlbumGroup>,
    #[prost(message, repeated, tag = "6")]
    pub single_group: ::prost::alloc::vec::Vec<AlbumGroup>,
    #[prost(message, repeated, tag = "7")]
    pub compilation_group: ::prost::alloc::vec::Vec<AlbumGroup>,
    #[prost(message, repeated, tag = "8")]
    pub appears_on_group: ::prost::alloc::vec::Vec<AlbumGroup>,
    #[prost(string, repeated, tag = "9")]
    pub genre: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "10")]
    pub external_id: ::prost::alloc::vec::Vec<ExternalId>,
    /// Deprecated, use portrait_group instead
    #[prost(message, repeated, tag = "11")]
    pub portrait: ::prost::alloc::vec::Vec<Image>,
    #[prost(message, repeated, tag = "12")]
    pub biography: ::prost::alloc::vec::Vec<Biography>,
    #[prost(message, repeated, tag = "13")]
    pub activity_period: ::prost::alloc::vec::Vec<ActivityPeriod>,
    #[prost(message, repeated, tag = "14")]
    pub restriction: ::prost::alloc::vec::Vec<Restriction>,
    /// Only artist.gid will be set
    #[prost(message, repeated, tag = "15")]
    pub related: ::prost::alloc::vec::Vec<Artist>,
    #[prost(bool, optional, tag = "16")]
    pub is_portrait_album_cover: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "17")]
    pub portrait_group: ::core::option::Option<ImageGroup>,
    #[prost(message, repeated, tag = "18")]
    pub sale_period: ::prost::alloc::vec::Vec<SalePeriod>,
    #[prost(message, repeated, tag = "19")]
    pub localized_name: ::prost::alloc::vec::Vec<LocalizedString>,
    #[prost(message, repeated, tag = "20")]
    pub availability: ::prost::alloc::vec::Vec<Availability>,
    /// Version of the index this entity was built in. Hidden internal field, should not escape to metadata clients
    #[prost(int64, optional, tag = "21")]
    pub index_version: ::core::option::Option<i64>,
    /// Hidden internal field, used to optimize encoding of top tracks. Should not escape to metadata clients
    #[prost(message, repeated, tag = "22")]
    pub compressed_top_track: ::prost::alloc::vec::Vec<CompressedTopTracks>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Album {
    /// \[mandatory\]
    ///
    /// 16 bytes
    #[prost(bytes = "vec", optional, tag = "1")]
    pub gid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// \[mandatory\]
    ///
    /// Concatenation of the album original title and version title
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// \[mandatory\]
    ///
    /// only artist.gid, artist.name will be set
    #[prost(message, repeated, tag = "3")]
    pub artist: ::prost::alloc::vec::Vec<Artist>,
    /// \[mandatory\]
    #[prost(enumeration = "album::Type", optional, tag = "4")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    pub label: ::core::option::Option<::prost::alloc::string::String>,
    /// Original release date of the album
    #[prost(message, optional, tag = "6")]
    pub date: ::core::option::Option<Date>,
    /// 0-100
    #[prost(sint32, optional, tag = "7")]
    pub popularity: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "8")]
    pub genre: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Deprecated, use cover_group instead
    #[prost(message, repeated, tag = "9")]
    pub cover: ::prost::alloc::vec::Vec<Image>,
    #[prost(message, repeated, tag = "10")]
    pub external_id: ::prost::alloc::vec::Vec<ExternalId>,
    #[prost(message, repeated, tag = "11")]
    pub disc: ::prost::alloc::vec::Vec<Disc>,
    #[prost(string, repeated, tag = "12")]
    pub review: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "13")]
    pub copyright: ::prost::alloc::vec::Vec<Copyright>,
    #[prost(message, repeated, tag = "14")]
    pub restriction: ::prost::alloc::vec::Vec<Restriction>,
    /// only album.gid will be set
    #[prost(message, repeated, tag = "15")]
    pub related: ::prost::alloc::vec::Vec<Album>,
    #[prost(message, repeated, tag = "16")]
    pub sale_period: ::prost::alloc::vec::Vec<SalePeriod>,
    #[prost(message, optional, tag = "17")]
    pub cover_group: ::core::option::Option<ImageGroup>,
    #[prost(string, optional, tag = "18")]
    pub original_title: ::core::option::Option<::prost::alloc::string::String>,
    /// The version of this album, eg: remix, remaster...
    #[prost(string, optional, tag = "19")]
    pub version_title: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "20")]
    pub type_str: ::core::option::Option<::prost::alloc::string::String>,
    /// Hidden internal field, should not escape to metadata clients
    #[prost(message, repeated, tag = "21")]
    pub visibility_block: ::prost::alloc::vec::Vec<Block>,
    /// UTC timestamp (in seconds) of when an album is playable in at least one market and allowed to be exposed in the metadata service. This is not guaranteed to remain stable over time
    #[prost(int64, optional, tag = "22")]
    pub earliest_live_timestamp: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "23")]
    pub availability: ::prost::alloc::vec::Vec<Availability>,
    /// Hidden internal field, should not escape to metadata clients
    #[prost(message, repeated, tag = "24")]
    pub windowed_track: ::prost::alloc::vec::Vec<Track>,
    #[prost(message, optional, tag = "25")]
    pub licensor: ::core::option::Option<Licensor>,
    /// Version in seconds since epoch. Hidden internal field, should not escape to metadata clients
    #[prost(int64, optional, tag = "26")]
    pub version: ::core::option::Option<i64>,
    /// Hidden internal field, should not escape to metadata clients
    #[prost(string, optional, tag = "27")]
    pub feed_gid: ::core::option::Option<::prost::alloc::string::String>,
    /// Hidden internal field, should not escape to metadata clients
    #[prost(string, optional, tag = "28")]
    pub delivery_id: ::core::option::Option<::prost::alloc::string::String>,
    #[deprecated]
    #[prost(message, repeated, tag = "29")]
    pub localized_name: ::prost::alloc::vec::Vec<LocalizedString>,
    /// Version of the index this entity was built in. Hidden internal field, should not escape to metadata clients
    #[prost(int64, optional, tag = "30")]
    pub index_version: ::core::option::Option<i64>,
    /// 16 bytes (UUID). The segment block gids this album has active. Hidden internal field, should not escape to metadata clients
    #[prost(bytes = "vec", repeated, tag = "31")]
    pub segment_block_gid: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag = "32")]
    pub courtesy_line: ::core::option::Option<::prost::alloc::string::String>,
    /// All titles for the Album. Hidden internal field, should not escape to metadata clients
    #[prost(message, repeated, tag = "33")]
    pub title: ::prost::alloc::vec::Vec<LocalizedTitle>,
    /// If true, means no metadata should be surfaced in clients for this album for legal reasons
    #[prost(bool, optional, tag = "34")]
    pub is_metadata_hidden: ::core::option::Option<bool>,
    /// Highest ranked album in the album group
    #[prost(string, optional, tag = "35")]
    pub canonical_uri: ::core::option::Option<::prost::alloc::string::String>,
    /// Hidden internal field, not exposed publicly. If you need artist roles for albums, please consider migrating to V5 API
    #[prost(message, repeated, tag = "36")]
    pub artist_with_role: ::prost::alloc::vec::Vec<ArtistWithRole>,
    /// Prerelease data, should only be set for the allowlisted clients
    #[prost(message, optional, tag = "37")]
    pub prerelease_config: ::core::option::Option<AlbumPrerelease>,
    #[prost(message, repeated, tag = "38")]
    pub label_id: ::prost::alloc::vec::Vec<LabelId>,
    /// Hidden internal field.
    #[prost(message, optional, tag = "39")]
    pub implementation_details: ::core::option::Option<AlbumImplDetails>,
    #[prost(message, repeated, tag = "40")]
    pub release_admin: ::prost::alloc::vec::Vec<ReleaseAdmin>,
}
/// Nested message and enum types in `Album`.
pub mod album {
    #[derive(serde::Deserialize, serde::Serialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Foo = 0,
        Album = 1,
        Single = 2,
        Compilation = 3,
        Ep = 4,
        Audiobook = 5,
        Podcast = 6,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Foo => "FOO",
                Type::Album => "ALBUM",
                Type::Single => "SINGLE",
                Type::Compilation => "COMPILATION",
                Type::Ep => "EP",
                Type::Audiobook => "AUDIOBOOK",
                Type::Podcast => "PODCAST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FOO" => Some(Self::Foo),
                "ALBUM" => Some(Self::Album),
                "SINGLE" => Some(Self::Single),
                "COMPILATION" => Some(Self::Compilation),
                "EP" => Some(Self::Ep),
                "AUDIOBOOK" => Some(Self::Audiobook),
                "PODCAST" => Some(Self::Podcast),
                _ => None,
            }
        }
    }
}
/// Implementation details about an album. You should never assume any of this exists when requesting data about albums,
/// and you must be prepared for BREAKING changes to this in patch releases, including removing this entire type and its
/// corresponding field.
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlbumImplDetails {
    #[prost(string, optional, tag = "1")]
    pub media_type: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocalizedTitle {
    /// \[mandatory\]
    ///
    /// Language and script as defined in IETF RfC 5646(lowercase). Language and Script are provided as lang[-script][-region][-variant] - e.g., en, en-us etc
    #[prost(string, optional, tag = "1")]
    pub language: ::core::option::Option<::prost::alloc::string::String>,
    /// \[mandatory\]
    ///
    /// Only one default=true per entity.
    #[prost(bool, optional, tag = "2")]
    pub is_default: ::core::option::Option<bool>,
    /// \[mandatory\]
    ///
    /// Complete title, with any subtitle(s) in a single string - e.g., Rocking the Decks (Crunked Out Mix)
    #[prost(string, optional, tag = "3")]
    pub display_text: ::core::option::Option<::prost::alloc::string::String>,
    /// \[mandatory\]
    ///
    /// Main(clean) title - e.g., Rocking the Decks
    #[prost(string, optional, tag = "4")]
    pub title: ::core::option::Option<::prost::alloc::string::String>,
    /// If available, subtitle or version information in a separate field - e.g., Crunked Out Mix, instrumental version etc
    #[prost(string, optional, tag = "5")]
    pub subtitle: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Track {
    /// \[mandatory\]
    ///
    /// 16 bytes
    #[prost(bytes = "vec", optional, tag = "1")]
    pub gid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// \[mandatory\]
    ///
    /// Concatenation of the track original title and version title
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// \[mandatory\]
    /// only the following fields will be set:
    ///    album.gid, album.name,
    ///    album.artist.gid, album.artist.name
    /// the following fields will be set if they are set in the album:
    ///    album.label, album.date, album.genre
    #[prost(message, optional, tag = "3")]
    pub album: ::core::option::Option<Album>,
    /// only artist.gid, artist.name will be set
    #[prost(message, repeated, tag = "4")]
    pub artist: ::prost::alloc::vec::Vec<Artist>,
    /// \[mandatory\]
    #[prost(sint32, optional, tag = "5")]
    pub number: ::core::option::Option<i32>,
    /// \[mandatory\]
    #[prost(sint32, optional, tag = "6")]
    pub disc_number: ::core::option::Option<i32>,
    /// Milliseconds
    #[prost(sint32, optional, tag = "7")]
    pub duration: ::core::option::Option<i32>,
    /// 0-100
    #[prost(sint32, optional, tag = "8")]
    pub popularity: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "9")]
    pub explicit: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "10")]
    pub external_id: ::prost::alloc::vec::Vec<ExternalId>,
    #[prost(message, repeated, tag = "11")]
    pub restriction: ::prost::alloc::vec::Vec<Restriction>,
    #[prost(message, repeated, tag = "12")]
    pub file: ::prost::alloc::vec::Vec<AudioFile>,
    /// only track.gid will be set
    #[prost(message, repeated, tag = "13")]
    pub alternative: ::prost::alloc::vec::Vec<Track>,
    #[prost(message, repeated, tag = "14")]
    pub sale_period: ::prost::alloc::vec::Vec<SalePeriod>,
    #[prost(message, repeated, tag = "15")]
    pub preview: ::prost::alloc::vec::Vec<AudioFile>,
    /// freeform, for experimental features, etc.
    #[prost(string, repeated, tag = "16")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// UTC timestamp (in seconds) of when a track is playable in at least one market and allowed to be exposed in the metadata service. This is not guaranteed to remain stable over time
    #[prost(int64, optional, tag = "17")]
    pub earliest_live_timestamp: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "18")]
    pub has_lyrics: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "19")]
    pub availability: ::prost::alloc::vec::Vec<Availability>,
    /// Hidden internal field, should not escape to metadata clients
    #[prost(string, repeated, tag = "20")]
    pub lyrics_country: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "21")]
    pub licensor: ::core::option::Option<Licensor>,
    /// BCP 47 language codes
    #[prost(string, repeated, tag = "22")]
    pub language_of_performance: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[deprecated]
    #[prost(message, repeated, tag = "23")]
    pub localized_name: ::prost::alloc::vec::Vec<LocalizedString>,
    #[prost(message, optional, tag = "24")]
    pub original_audio: ::core::option::Option<Audio>,
    #[prost(message, repeated, tag = "25")]
    pub content_rating: ::prost::alloc::vec::Vec<ContentRating>,
    /// Version of the index this entity was built in. Hidden internal field, should not escape to metadata clients
    #[prost(int64, optional, tag = "26")]
    pub index_version: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "27")]
    pub original_title: ::core::option::Option<::prost::alloc::string::String>,
    /// The version of this track, eg: remix, remaster...
    #[prost(string, optional, tag = "28")]
    pub version_title: ::core::option::Option<::prost::alloc::string::String>,
    /// 16 bytes (UUID). The segment block gids this track has active. Hidden internal field, should not escape to metadata clients
    #[prost(bytes = "vec", repeated, tag = "31")]
    pub segment_block_gid: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// artists and their roles. Can be used together with version_title to add formatting to original_title
    #[prost(message, repeated, tag = "32")]
    pub artist_with_role: ::prost::alloc::vec::Vec<ArtistWithRole>,
    /// All titles for the Track. Hidden internal field, should not escape to metadata clients
    #[prost(message, repeated, tag = "33")]
    pub title: ::prost::alloc::vec::Vec<LocalizedTitle>,
    /// If true, means no metadata should be surfaced in clients for this track for legal reasons
    #[prost(bool, optional, tag = "34")]
    pub is_metadata_hidden: ::core::option::Option<bool>,
    /// Hidden internal field, should not escape to metadata clients
    #[prost(message, repeated, tag = "35")]
    pub visibility_block: ::prost::alloc::vec::Vec<Block>,
    /// Highest ranked track in the track link group
    #[prost(string, optional, tag = "36")]
    pub canonical_uri: ::core::option::Option<::prost::alloc::string::String>,
    /// Prerelease data, should only be set for the allowlisted clients
    #[prost(message, optional, tag = "37")]
    pub prerelease_config: ::core::option::Option<TrackPrerelease>,
    /// Video asset, only present if the track is a music video.
    /// In this case "Audio original_audio = 24" will contain an extracted audio of the ingested video,
    /// and is supposed to be used as a fallback for clients that are not capable of playing video.
    #[prost(message, repeated, tag = "38")]
    pub original_video: ::prost::alloc::vec::Vec<Video>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArtistWithRole {
    /// \[mandatory\]
    #[prost(bytes = "vec", optional, tag = "1")]
    pub artist_gid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// \[mandatory\]
    #[prost(string, optional, tag = "2")]
    pub artist_name: ::core::option::Option<::prost::alloc::string::String>,
    /// \[mandatory\]
    #[prost(enumeration = "artist_with_role::ArtistRole", optional, tag = "3")]
    pub role: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "4")]
    pub localized_name: ::prost::alloc::vec::Vec<LocalizedString>,
}
/// Nested message and enum types in `ArtistWithRole`.
pub mod artist_with_role {
    /// The ArtistRole enum represents the list of artist roles currently exposed by the metadata service.
    /// For non-classical content we expose the roles "main artist", "featured artist", "remixer", and "actor".
    /// For classical content we also expose "composer", "conductor" and "orchestra".
    #[derive(serde::Deserialize, serde::Serialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ArtistRole {
        Unknown = 0,
        MainArtist = 1,
        FeaturedArtist = 2,
        Remixer = 3,
        Actor = 4,
        Composer = 5,
        Conductor = 6,
        Orchestra = 7,
    }
    impl ArtistRole {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ArtistRole::Unknown => "ARTIST_ROLE_UNKNOWN",
                ArtistRole::MainArtist => "ARTIST_ROLE_MAIN_ARTIST",
                ArtistRole::FeaturedArtist => "ARTIST_ROLE_FEATURED_ARTIST",
                ArtistRole::Remixer => "ARTIST_ROLE_REMIXER",
                ArtistRole::Actor => "ARTIST_ROLE_ACTOR",
                ArtistRole::Composer => "ARTIST_ROLE_COMPOSER",
                ArtistRole::Conductor => "ARTIST_ROLE_CONDUCTOR",
                ArtistRole::Orchestra => "ARTIST_ROLE_ORCHESTRA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ARTIST_ROLE_UNKNOWN" => Some(Self::Unknown),
                "ARTIST_ROLE_MAIN_ARTIST" => Some(Self::MainArtist),
                "ARTIST_ROLE_FEATURED_ARTIST" => Some(Self::FeaturedArtist),
                "ARTIST_ROLE_REMIXER" => Some(Self::Remixer),
                "ARTIST_ROLE_ACTOR" => Some(Self::Actor),
                "ARTIST_ROLE_COMPOSER" => Some(Self::Composer),
                "ARTIST_ROLE_CONDUCTOR" => Some(Self::Conductor),
                "ARTIST_ROLE_ORCHESTRA" => Some(Self::Orchestra),
                _ => None,
            }
        }
    }
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Show {
    /// \[mandatory\]
    ///
    /// 16 bytes
    #[prost(bytes = "vec", optional, tag = "1")]
    pub gid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// \[mandatory\]
    ///
    /// Will contain PII information if is_creator_channel is set to true. Please read the implications of handling this piece of content at <https://backstage.spotify.net/docs/default/component/data-protection-privacy>
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "29")]
    pub localized_name: ::prost::alloc::vec::Vec<LocalizedString>,
    /// / Show specific fields
    ///
    /// Will contain PII information if is_creator_channel is set to true. Please read the implications of handling this piece of content at <https://backstage.spotify.net/docs/default/component/data-protection-privacy>
    #[prost(string, optional, tag = "64")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[deprecated]
    #[prost(sint32, optional, tag = "65")]
    pub deprecated_popularity: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "66")]
    pub publisher: ::core::option::Option<::prost::alloc::string::String>,
    /// in BCP 47 format
    #[prost(string, optional, tag = "67")]
    pub language: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "68")]
    pub explicit: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "69")]
    pub cover_image: ::core::option::Option<ImageGroup>,
    /// only episode.gid will be set
    #[prost(message, repeated, tag = "70")]
    pub episode: ::prost::alloc::vec::Vec<Episode>,
    #[prost(message, repeated, tag = "71")]
    pub copyright: ::prost::alloc::vec::Vec<Copyright>,
    #[prost(message, repeated, tag = "72")]
    pub restriction: ::prost::alloc::vec::Vec<Restriction>,
    #[prost(string, repeated, tag = "73")]
    pub keyword: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "show::MediaType", optional, tag = "74")]
    pub media_type: ::core::option::Option<i32>,
    #[prost(enumeration = "show::ConsumptionOrder", optional, tag = "75")]
    pub consumption_order: ::core::option::Option<i32>,
    #[deprecated]
    #[prost(bool, optional, tag = "76")]
    pub interpret_restriction_using_geoip: ::core::option::Option<bool>,
    /// combines information from ingested sale periods, curated sale period patches and segment block periods, so it is perhaps more appropriate to interpret these at this point as "availability periods"
    #[prost(message, repeated, tag = "77")]
    pub sale_period: ::prost::alloc::vec::Vec<SalePeriod>,
    #[prost(message, repeated, tag = "78")]
    pub availability: ::prost::alloc::vec::Vec<Availability>,
    #[prost(string, optional, tag = "79")]
    pub country_of_origin: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "80")]
    pub categories: ::prost::alloc::vec::Vec<Categories>,
    #[prost(enumeration = "show::Passthrough", optional, tag = "81")]
    pub passthrough: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "82")]
    pub employee_only: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "83")]
    pub trailer_uri: ::core::option::Option<::prost::alloc::string::String>,
    /// This is temporary and accessible by specific backend services.
    /// This will be deprecated once the v5 version of the metadata api is out.
    ///
    /// Will contain PII information if is_creator_channel is set to true. Please read the implications of handling this piece of content at <https://backstage.spotify.net/docs/default/component/data-protection-privacy>
    #[prost(string, optional, tag = "84")]
    pub html_description: ::core::option::Option<::prost::alloc::string::String>,
    /// Is this a music and talk show. This is defined as more than 50% of this show is made up of music and talk episodes.
    #[prost(bool, optional, tag = "85")]
    pub music_and_talk: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "86")]
    pub authorization: ::core::option::Option<Authorization>,
    #[prost(bool, optional, tag = "87")]
    pub is_enterprise_content: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "88")]
    pub show_type: ::core::option::Option<ShowType>,
    #[prost(bool, optional, tag = "89")]
    pub is_audiobook: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "90")]
    pub is_creator_channel: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "91")]
    pub is_searchable: ::core::option::Option<bool>,
    /// Field is never populated and was added by mistake, if you need this field please use show-api service instead
    #[prost(string, optional, tag = "92")]
    pub deprecated_spotify_user_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(bool, optional, tag = "93")]
    pub is_paywall_content: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "94")]
    pub is_podcast_show: ::core::option::Option<bool>,
}
/// Nested message and enum types in `Show`.
pub mod show {
    /// / Minimal playable audio entity "collection" fields
    /// These fields are intentionally using the same numbers as for Album, because old hardware
    /// speakers would reinterpret_cast<>() them into Album.  This probably doesn't happen any more,
    /// but to be safe we add any fields that are common to both Show and Album in the 1..63 block.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MediaType {
        Mixed = 0,
        Audio = 1,
        Video = 2,
    }
    impl MediaType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MediaType::Mixed => "MIXED",
                MediaType::Audio => "AUDIO",
                MediaType::Video => "VIDEO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MIXED" => Some(Self::Mixed),
                "AUDIO" => Some(Self::Audio),
                "VIDEO" => Some(Self::Video),
                _ => None,
            }
        }
    }
    #[derive(serde::Deserialize, serde::Serialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConsumptionOrder {
        /// omitting 0 so that there is no default
        Foo = 0,
        Sequential = 1,
        Episodic = 2,
        Recent = 3,
    }
    impl ConsumptionOrder {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConsumptionOrder::Foo => "FOO",
                ConsumptionOrder::Sequential => "SEQUENTIAL",
                ConsumptionOrder::Episodic => "EPISODIC",
                ConsumptionOrder::Recent => "RECENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FOO" => Some(Self::Foo),
                "SEQUENTIAL" => Some(Self::Sequential),
                "EPISODIC" => Some(Self::Episodic),
                "RECENT" => Some(Self::Recent),
                _ => None,
            }
        }
    }
    #[derive(serde::Deserialize, serde::Serialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Passthrough {
        Unknown = 0,
        None = 1,
        /// aka: cat 2 passthrough; this can fallback to transcoded audio
        Allowed = 2,
        /// aka: cat 3 passthrough; no fallback
        Mandatory = 3,
    }
    impl Passthrough {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Passthrough::Unknown => "UNKNOWN",
                Passthrough::None => "NONE",
                Passthrough::Allowed => "ALLOWED",
                Passthrough::Mandatory => "MANDATORY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "NONE" => Some(Self::None),
                "ALLOWED" => Some(Self::Allowed),
                "MANDATORY" => Some(Self::Mandatory),
                _ => None,
            }
        }
    }
}
/// / Minimal playable audio entity fields
/// These fields are intentionally using the same numbers as for Track, because old hardware
/// speakers would reinterpret_cast<>() them into Track.  This probably doesn't happen any more,
/// but to be safe we add any fields that are common to both Episode and Track in the 1..63 block.
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Episode {
    /// \[mandatory\]
    ///
    /// 16 bytes
    #[prost(bytes = "vec", optional, tag = "1")]
    pub gid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// \[mandatory\]
    ///
    /// Will contain PII information if is_podcast_short is set to true. Please read the implications of handling this piece of content at <https://backstage.spotify.net/docs/default/component/data-protection-privacy>
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// milliseconds
    #[prost(sint32, optional, tag = "7")]
    pub duration: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "12")]
    pub audio: ::prost::alloc::vec::Vec<AudioFile>,
    #[prost(message, repeated, tag = "23")]
    pub localized_name: ::prost::alloc::vec::Vec<LocalizedString>,
    /// / Episode specific fields
    ///
    /// Will contain PII information if is_podcast_short is set to true. Please read the implications of handling this piece of content at <https://backstage.spotify.net/docs/default/component/data-protection-privacy>
    #[prost(string, optional, tag = "64")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// semantic, starting from 1
    #[prost(sint32, optional, tag = "65")]
    pub number: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "66")]
    pub publish_time: ::core::option::Option<Date>,
    /// 0-100
    #[deprecated]
    #[prost(sint32, optional, tag = "67")]
    pub deprecated_popularity: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "68")]
    pub cover_image: ::core::option::Option<ImageGroup>,
    /// in BCP 47 format
    #[prost(string, optional, tag = "69")]
    pub language: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "70")]
    pub explicit: ::core::option::Option<bool>,
    /// only show.gid, show.name will be set
    #[prost(message, optional, tag = "71")]
    pub show: ::core::option::Option<Show>,
    #[prost(message, repeated, tag = "72")]
    pub video: ::prost::alloc::vec::Vec<VideoFile>,
    #[prost(message, repeated, tag = "73")]
    pub video_preview: ::prost::alloc::vec::Vec<VideoFile>,
    #[prost(message, repeated, tag = "74")]
    pub audio_preview: ::prost::alloc::vec::Vec<AudioFile>,
    #[prost(message, repeated, tag = "75")]
    pub restriction: ::prost::alloc::vec::Vec<Restriction>,
    #[prost(message, optional, tag = "76")]
    pub freeze_frame: ::core::option::Option<ImageGroup>,
    #[prost(string, repeated, tag = "77")]
    pub keyword: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[deprecated]
    #[prost(bool, optional, tag = "78")]
    pub interpret_restriction_using_geoip: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "79")]
    pub suppress_monetization: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "80")]
    pub sale_period: ::prost::alloc::vec::Vec<SalePeriod>,
    #[prost(bool, optional, tag = "81")]
    pub allow_background_playback: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "82")]
    pub availability: ::prost::alloc::vec::Vec<Availability>,
    #[prost(string, optional, tag = "83")]
    pub external_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "84")]
    pub original_audio: ::core::option::Option<Audio>,
    #[prost(bool, optional, tag = "85")]
    pub employee_only: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "86")]
    pub rss_guid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "episode::EpisodeType", optional, tag = "87")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "88")]
    pub season_number: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "89")]
    pub episode_number: ::core::option::Option<i32>,
    /// This is temporary and accessible by specific backend services.
    /// This will be deprecated once the v5 version of the metadata api is out.
    ///
    /// Will contain PII information if is_podcast_short is set to true. Please read the implications of handling this piece of content at <https://backstage.spotify.net/docs/default/component/data-protection-privacy>
    #[prost(string, optional, tag = "90")]
    pub html_description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "91")]
    pub music_and_talk: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "92")]
    pub authorization: ::core::option::Option<Authorization>,
    #[prost(bool, optional, tag = "93")]
    pub is_enterprise_content: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "94")]
    pub is_paywall_content: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "95")]
    pub content_rating: ::prost::alloc::vec::Vec<ContentRating>,
    #[prost(bool, optional, tag = "96")]
    pub is_audiobook_chapter: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "97")]
    pub is_podcast_short: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "98")]
    pub is_searchable: ::core::option::Option<bool>,
    /// Field is never populated and was added by mistake, if you need this field please use episode-api service instead
    #[prost(string, optional, tag = "99")]
    pub deprecated_spotify_user_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(bool, optional, tag = "100")]
    pub is_podcast_episode: ::core::option::Option<bool>,
}
/// Nested message and enum types in `Episode`.
pub mod episode {
    #[derive(serde::Deserialize, serde::Serialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EpisodeType {
        Full = 0,
        Trailer = 1,
        Bonus = 2,
    }
    impl EpisodeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EpisodeType::Full => "FULL",
                EpisodeType::Trailer => "TRAILER",
                EpisodeType::Bonus => "BONUS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FULL" => Some(Self::Full),
                "TRAILER" => Some(Self::Trailer),
                "BONUS" => Some(Self::Bonus),
                _ => None,
            }
        }
    }
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Licensor {
    /// \[mandatory\]
    #[prost(bytes = "vec", optional, tag = "1")]
    pub uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Original audio that was submitted to transcoding
/// This is used to get all transcodings available for a certain audio
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Audio {
    /// \[mandatory\]
    #[prost(bytes = "vec", optional, tag = "1")]
    pub uuid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Maps country -> list of tracks. Tracks should be
/// orderered by popularity with most popular first.
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopTracks {
    /// \[mandatory\]
    ///
    /// ISO 3166-1 alpha-2 code
    #[prost(string, optional, tag = "1")]
    pub country: ::core::option::Option<::prost::alloc::string::String>,
    /// Only track.gid will be set
    #[prost(message, repeated, tag = "2")]
    pub track: ::prost::alloc::vec::Vec<Track>,
}
/// Used to compress the representation of top tracks, since
/// top lists are usually the same for most countries
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompressedTopTracks {
    #[prost(string, repeated, tag = "1")]
    pub country: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub track: ::prost::alloc::vec::Vec<Track>,
}
/// If decade is set, none of the other fields will be set.
/// At least one field must be set
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityPeriod {
    #[prost(sint32, optional, tag = "1")]
    pub start_year: ::core::option::Option<i32>,
    #[prost(sint32, optional, tag = "2")]
    pub end_year: ::core::option::Option<i32>,
    #[prost(sint32, optional, tag = "3")]
    pub decade: ::core::option::Option<i32>,
}
/// In order to support grouping of similar albums (same tracks, etc., but
/// available in different territories for instance) we need to add an extra
/// level here.
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlbumGroup {
    /// only album.gid will be set
    #[prost(message, repeated, tag = "1")]
    pub album: ::prost::alloc::vec::Vec<Album>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Date {
    /// \[mandatory\]
    ///
    /// calendar year
    #[prost(sint32, optional, tag = "1")]
    pub year: ::core::option::Option<i32>,
    /// month of year, one-based
    #[prost(sint32, optional, tag = "2")]
    pub month: ::core::option::Option<i32>,
    /// day of month, one-based
    #[prost(sint32, optional, tag = "3")]
    pub day: ::core::option::Option<i32>,
    #[prost(sint32, optional, tag = "4")]
    pub hour: ::core::option::Option<i32>,
    #[prost(sint32, optional, tag = "5")]
    pub minute: ::core::option::Option<i32>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Image {
    /// \[mandatory\]
    ///
    /// 20 bytes
    #[prost(bytes = "vec", optional, tag = "1")]
    pub file_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// \[mandatory\]
    #[prost(enumeration = "image::Size", optional, tag = "2")]
    pub size: ::core::option::Option<i32>,
    /// pixel width of the specific file - not the original
    #[prost(sint32, optional, tag = "3")]
    pub width: ::core::option::Option<i32>,
    #[prost(sint32, optional, tag = "4")]
    pub height: ::core::option::Option<i32>,
}
/// Nested message and enum types in `Image`.
pub mod image {
    #[derive(serde::Deserialize, serde::Serialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Size {
        Default = 0,
        Small = 1,
        Large = 2,
        Xlarge = 3,
        Xxlarge = 4,
    }
    impl Size {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Size::Default => "DEFAULT",
                Size::Small => "SMALL",
                Size::Large => "LARGE",
                Size::Xlarge => "XLARGE",
                Size::Xxlarge => "XXLARGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEFAULT" => Some(Self::Default),
                "SMALL" => Some(Self::Small),
                "LARGE" => Some(Self::Large),
                "XLARGE" => Some(Self::Xlarge),
                "XXLARGE" => Some(Self::Xxlarge),
                _ => None,
            }
        }
    }
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageGroup {
    #[prost(message, repeated, tag = "1")]
    pub image: ::prost::alloc::vec::Vec<Image>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Biography {
    #[prost(string, optional, tag = "1")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    /// Deprecated, use portrait_group instead
    #[prost(message, repeated, tag = "2")]
    pub portrait: ::prost::alloc::vec::Vec<Image>,
    #[prost(message, repeated, tag = "3")]
    pub portrait_group: ::prost::alloc::vec::Vec<ImageGroup>,
    #[prost(message, repeated, tag = "4")]
    pub localized_text: ::prost::alloc::vec::Vec<LocalizedString>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Disc {
    /// \[mandatory\]
    #[prost(sint32, optional, tag = "1")]
    pub number: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// only track.gid will be set
    #[prost(message, repeated, tag = "3")]
    pub track: ::prost::alloc::vec::Vec<Track>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Copyright {
    /// \[mandatory\]
    #[prost(enumeration = "copyright::Type", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    /// \[mandatory\]
    #[prost(string, optional, tag = "2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Copyright`.
pub mod copyright {
    #[derive(serde::Deserialize, serde::Serialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        P = 0,
        C = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::P => "P",
                Type::C => "C",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "P" => Some(Self::P),
                "C" => Some(Self::C),
                _ => None,
            }
        }
    }
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Restriction {
    /// Will not be set in the future, use the new metadata API's and the catalogue_str field instead.
    #[prost(enumeration = "restriction::Catalogue", repeated, tag = "1")]
    pub catalogue: ::prost::alloc::vec::Vec<i32>,
    /// If not set, it is both STREAMING and DOWNLOAD
    #[prost(enumeration = "restriction::Type", optional, tag = "4")]
    pub r#type: ::core::option::Option<i32>,
    /// New way of communicating the catalogue. Will not be set at the same time as catalogue
    #[prost(string, repeated, tag = "5")]
    pub catalogue_str: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(oneof = "restriction::CountryRestriction", tags = "2, 3")]
    pub country_restriction: ::core::option::Option<restriction::CountryRestriction>,
}
/// Nested message and enum types in `Restriction`.
pub mod restriction {
    /// Deprecated enum of catalogues. At some point we will stop adding new catalogues and just use
    /// a string instead
    #[derive(serde::Deserialize, serde::Serialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Catalogue {
        Ad = 0,
        Subscription = 1,
        All = 2,
        Shuffle = 3,
        Commercial = 4,
    }
    impl Catalogue {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Catalogue::Ad => "AD",
                Catalogue::Subscription => "SUBSCRIPTION",
                Catalogue::All => "CATALOGUE_ALL",
                Catalogue::Shuffle => "SHUFFLE",
                Catalogue::Commercial => "COMMERCIAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AD" => Some(Self::Ad),
                "SUBSCRIPTION" => Some(Self::Subscription),
                "CATALOGUE_ALL" => Some(Self::All),
                "SHUFFLE" => Some(Self::Shuffle),
                "COMMERCIAL" => Some(Self::Commercial),
                _ => None,
            }
        }
    }
    #[derive(serde::Deserialize, serde::Serialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Streaming = 0,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Streaming => "STREAMING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STREAMING" => Some(Self::Streaming),
                _ => None,
            }
        }
    }
    #[derive(serde::Deserialize, serde::Serialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CountryRestriction {
        /// Repeated ISO 3166-1 alpha-2 codes, e.g. "FINOSE"
        #[prost(string, tag = "2")]
        CountriesAllowed(::prost::alloc::string::String),
        /// Repeated ISO 3166-1 alpha-2 codes, e.g. "ATCHDE"
        #[prost(string, tag = "3")]
        CountriesForbidden(::prost::alloc::string::String),
    }
}
/// An indication of when a restricted entity is available.  All of the conditions of the
/// availability need to hold, i.e. if "catalogue_str" and "start" is set, it means
/// "The entity will be available in the specified catalogue(s) after the given date."
/// To express "The entity is available in the specified catalogue" OR "The entity will be
/// available after a certain date," two different Availability messages should be used.
/// This means that a consumer of this message SHOULD check if there are any unknown
/// fields and if so discard the Availability, since it contains conditions that might not
/// hold for that consumer.
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Availability {
    /// The entity is available in the specified catalogues, so if the user would switch to
    /// one of these catalogues, the entity would most likely be available.
    #[prost(string, repeated, tag = "1")]
    pub catalogue_str: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The entity is available after the specified date (inclusive).
    #[prost(message, optional, tag = "2")]
    pub start: ::core::option::Option<Date>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Categories {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub subcategories: ::prost::alloc::vec::Vec<SubCategories>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubCategories {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SalePeriod {
    /// \[mandatory\]
    #[prost(message, repeated, tag = "1")]
    pub restriction: ::prost::alloc::vec::Vec<Restriction>,
    /// Missing start date indicates that the saleperiod was valid
    /// since before the index was built
    #[prost(message, optional, tag = "2")]
    pub start: ::core::option::Option<Date>,
    /// Missing end date indicates that the saleperiod
    /// will be valid at least until the next index
    #[prost(message, optional, tag = "3")]
    pub end: ::core::option::Option<Date>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalId {
    /// \[mandatory\]
    #[prost(string, optional, tag = "1")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    /// \[mandatory\]
    #[prost(string, optional, tag = "2")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LabelId {
    /// \[mandatory\]
    #[prost(string, optional, tag = "1")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    /// \[mandatory\]
    #[prost(string, optional, tag = "2")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioFile {
    /// \[mandatory\]
    ///
    /// 20 bytes
    #[prost(bytes = "vec", optional, tag = "1")]
    pub file_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// \[mandatory\]
    #[prost(enumeration = "audio_file::Format", optional, tag = "2")]
    pub format: ::core::option::Option<i32>,
}
/// Nested message and enum types in `AudioFile`.
pub mod audio_file {
    #[derive(serde::Deserialize, serde::Serialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Format {
        OggVorbis96 = 0,
        OggVorbis160 = 1,
        OggVorbis320 = 2,
        Mp3256 = 3,
        Mp3320 = 4,
        /// Unencrypted, 1 substream
        Mp3160 = 5,
        /// Unencrypted, 1 substream, for previews
        Mp396 = 6,
        /// Encrypted, 1 substream, rc4
        Mp3160Enc = 7,
        /// Encrypted, 1 substream, aes
        Aac24 = 8,
        /// Encrypted, 1 substream, aes
        Aac48 = 9,
        /// AAC + EME, web audio
        Mp4128 = 10,
        /// AAC + EME, web audio
        Mp4256 = 11,
        /// dual DRM
        Mp4128Dual = 12,
        /// dual DRM
        Mp4256Dual = 13,
        /// AAC + EME, AES-CBCS for fairplay
        Mp4128Cbcs = 14,
        /// AAC + EME, AES-CBCS for fairplay
        Mp4256Cbcs = 15,
        /// FLAC in FLAC container
        FlacFlac = 16,
        /// FLAC in MP4 container, for EME widevine
        Mp4Flac = 17,
        /// xHE-AAC 24 kbps in MP4 container
        XheAac24 = 18,
        /// xHE-AAC 16 kbps in MP4 container
        XheAac16 = 19,
        /// xHE-AAC 12 kbps in MP4 container
        XheAac12 = 20,
        /// HE-AACv1 64 kbps in MP4 container
        HeAac64 = 21,
        /// 24-bit FLAC in a FLAC container
        FlacFlac24bit = 22,
        /// 24-bit FLAC in a MP4 container
        Mp4Flac24bit = 23,
    }
    impl Format {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Format::OggVorbis96 => "OGG_VORBIS_96",
                Format::OggVorbis160 => "OGG_VORBIS_160",
                Format::OggVorbis320 => "OGG_VORBIS_320",
                Format::Mp3256 => "MP3_256",
                Format::Mp3320 => "MP3_320",
                Format::Mp3160 => "MP3_160",
                Format::Mp396 => "MP3_96",
                Format::Mp3160Enc => "MP3_160_ENC",
                Format::Aac24 => "AAC_24",
                Format::Aac48 => "AAC_48",
                Format::Mp4128 => "MP4_128",
                Format::Mp4256 => "MP4_256",
                Format::Mp4128Dual => "MP4_128_DUAL",
                Format::Mp4256Dual => "MP4_256_DUAL",
                Format::Mp4128Cbcs => "MP4_128_CBCS",
                Format::Mp4256Cbcs => "MP4_256_CBCS",
                Format::FlacFlac => "FLAC_FLAC",
                Format::Mp4Flac => "MP4_FLAC",
                Format::XheAac24 => "XHE_AAC_24",
                Format::XheAac16 => "XHE_AAC_16",
                Format::XheAac12 => "XHE_AAC_12",
                Format::HeAac64 => "HE_AAC_64",
                Format::FlacFlac24bit => "FLAC_FLAC_24BIT",
                Format::Mp4Flac24bit => "MP4_FLAC_24BIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OGG_VORBIS_96" => Some(Self::OggVorbis96),
                "OGG_VORBIS_160" => Some(Self::OggVorbis160),
                "OGG_VORBIS_320" => Some(Self::OggVorbis320),
                "MP3_256" => Some(Self::Mp3256),
                "MP3_320" => Some(Self::Mp3320),
                "MP3_160" => Some(Self::Mp3160),
                "MP3_96" => Some(Self::Mp396),
                "MP3_160_ENC" => Some(Self::Mp3160Enc),
                "AAC_24" => Some(Self::Aac24),
                "AAC_48" => Some(Self::Aac48),
                "MP4_128" => Some(Self::Mp4128),
                "MP4_256" => Some(Self::Mp4256),
                "MP4_128_DUAL" => Some(Self::Mp4128Dual),
                "MP4_256_DUAL" => Some(Self::Mp4256Dual),
                "MP4_128_CBCS" => Some(Self::Mp4128Cbcs),
                "MP4_256_CBCS" => Some(Self::Mp4256Cbcs),
                "FLAC_FLAC" => Some(Self::FlacFlac),
                "MP4_FLAC" => Some(Self::Mp4Flac),
                "XHE_AAC_24" => Some(Self::XheAac24),
                "XHE_AAC_16" => Some(Self::XheAac16),
                "XHE_AAC_12" => Some(Self::XheAac12),
                "HE_AAC_64" => Some(Self::HeAac64),
                "FLAC_FLAC_24BIT" => Some(Self::FlacFlac24bit),
                "MP4_FLAC_24BIT" => Some(Self::Mp4Flac24bit),
                _ => None,
            }
        }
    }
}
/// Represents the original video delivered to Spotify and registered on Playback systems
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Video {
    /// \[mandatory\]
    /// 16 bytes hex encoded UUID of the video
    /// This property is named source_id in Videophile and Director
    #[prost(bytes = "vec", optional, tag = "1")]
    pub gid: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Originally intended to represent a video file generated from transcoding an original video
/// Nowadays we don't store any information about video transcoded files on Metadata APIs
/// VideoFile.file_id actually returns the source_id of the original video for backwards compatibility
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoFile {
    /// \[mandatory\]
    ///
    /// 16 bytes
    #[prost(bytes = "vec", optional, tag = "1")]
    pub file_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Deprecated
    #[prost(message, repeated, tag = "2")]
    pub ad_placements: ::prost::alloc::vec::Vec<AdPlacement>,
    /// combines information from episode sale periods and video regional blocks
    #[prost(message, repeated, tag = "3")]
    pub sale_periods: ::prost::alloc::vec::Vec<SalePeriod>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdPlacement {
    #[prost(enumeration = "ad_placement::AdType", optional, tag = "1")]
    pub ad_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub start_time: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub finish_time: ::core::option::Option<i32>,
}
/// Nested message and enum types in `AdPlacement`.
pub mod ad_placement {
    #[derive(serde::Deserialize, serde::Serialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdType {
        /// pre-roll (before the video)
        Pre = 0,
        /// mid-roll (at a point in the middle)
        Mid = 1,
        /// post-roll (after the end of the video)
        Post = 2,
    }
    impl AdType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdType::Pre => "PRE",
                AdType::Mid => "MID",
                AdType::Post => "POST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PRE" => Some(Self::Pre),
                "MID" => Some(Self::Mid),
                "POST" => Some(Self::Post),
                _ => None,
            }
        }
    }
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Block {
    /// Can be omitted, with the implication that the block is world wide.
    ///
    /// Repeated ISO 3166-1 alpha-2 codes, e.g. "FINOSE"
    #[prost(string, optional, tag = "1")]
    pub countries: ::core::option::Option<::prost::alloc::string::String>,
    /// \[mandatory\]
    #[prost(enumeration = "block::Type", optional, tag = "2")]
    pub r#type: ::core::option::Option<i32>,
}
/// Nested message and enum types in `Block`.
pub mod block {
    #[derive(serde::Deserialize, serde::Serialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Complete block, every entity
        Total = 0,
        /// Block cover art and copyright lines
        Coverartcp = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Total => "TOTAL",
                Type::Coverartcp => "COVERARTCP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TOTAL" => Some(Self::Total),
                "COVERARTCP" => Some(Self::Coverartcp),
                _ => None,
            }
        }
    }
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContentRating {
    /// ISO 3166-1 alpha-2 code
    #[prost(string, optional, tag = "1")]
    pub country: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub tag: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// This is different from statements but consistent with v5 model
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Grant {
    #[prost(string, optional, tag = "1")]
    pub market: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub groups: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub is_override_grant: ::core::option::Option<bool>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrantV2 {
    #[prost(string, repeated, tag = "1")]
    pub markets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub group: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub is_override_grant: ::core::option::Option<bool>,
    /// Missing start date indicates that the grant was valid since before the index was built
    #[prost(message, optional, tag = "4")]
    pub start: ::core::option::Option<Date>,
    /// Missing end date indicates that the grant will bevalid at least until the next index
    #[prost(message, optional, tag = "5")]
    pub end: ::core::option::Option<Date>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Authorization {
    #[deprecated]
    #[prost(string, repeated, tag = "1")]
    pub groups: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Restrictions and sale periods would still apply regardless of
    /// the access tier.
    #[prost(bool, optional, tag = "2")]
    pub should_check_auth_groups: ::core::option::Option<bool>,
    #[deprecated]
    #[prost(message, repeated, tag = "3")]
    pub grants: ::prost::alloc::vec::Vec<Grant>,
    #[prost(message, repeated, tag = "4")]
    pub grants_v2: ::prost::alloc::vec::Vec<GrantV2>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowType {
    #[prost(bool, optional, tag = "1")]
    pub original: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "2")]
    pub exclusive: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3")]
    pub adaptation: ::core::option::Option<bool>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlbumPrerelease {
    #[prost(message, optional, tag = "1")]
    pub earliest_reveal_date: ::core::option::Option<Date>,
    #[prost(message, optional, tag = "2")]
    pub earliest_coverart_reveal_date: ::core::option::Option<Date>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrackPrerelease {
    #[prost(message, optional, tag = "1")]
    pub earliest_reveal_date: ::core::option::Option<Date>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReleaseAdmin {
    /// \[mandatory\]
    #[prost(string, optional, tag = "1")]
    pub release_admin_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub personnel_description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub system_description: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// When asking for the extension for an entity, the client can optionally
/// provide an ETag. If the ETag matches the extension value currently at
/// the server, the server returns the ETag and doesn't have to fill in the
/// actual value of the extension as the client already has it in its cache.
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtensionQuery {
    #[prost(enumeration = "ExtensionKind", tag = "1")]
    pub extension_kind: i32,
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// The client asks for a list of extensions for each entity.
///
/// Example:
/// {
///    entity_uri: "spotify:track:1",
///    query: [
///      ExtensionQuery(ExtensionKind::CANVAZ, $etag1canvaz),
///      ExtensionQuery(ExtensionKind::STORYLINES, "")
///    ]
/// }
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityRequest {
    #[prost(string, tag = "1")]
    pub entity_uri: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub query: ::prost::alloc::vec::Vec<ExtensionQuery>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchedEntityRequestHeader {
    /// Deprecated country and catalogue fields. These values will be taken from
    /// the user-info header instead.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub country: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(string, tag = "2")]
    pub catalogue: ::prost::alloc::string::String,
    /// The random 128-bit task ID used to correlate backend requests
    /// with client tasks. Multiple requests share the same task_id
    /// if they are all part of the same metadata fetching operation
    /// (e.g. fetching metadata fro 100s of tracks in a playlist).
    #[prost(bytes = "vec", tag = "3")]
    pub task_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchedEntityRequest {
    /// reserved
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<BatchedEntityRequestHeader>,
    #[prost(message, repeated, tag = "2")]
    pub entity_request: ::prost::alloc::vec::Vec<EntityRequest>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityExtensionDataArrayHeader {
    /// When the metadata provider request fails completely, this error code
    /// is set and the extension_data array will be empty.
    ///
    /// This field is internal to the backend and should be ignored by the client.
    #[deprecated]
    #[prost(int32, tag = "1")]
    pub provider_error_status: i32,
    /// Cache configuration for the data in the array. All extension values of
    /// the same extension kind get the same cache configuration by default. Note that the default
    /// TTLs can be overridden by per-entity cache TTLs specified in the enclosed
    /// EntityExtensionData messages.
    #[prost(int64, tag = "2")]
    pub cache_ttl_in_seconds: i64,
    #[deprecated]
    #[prost(int64, tag = "3")]
    pub offline_ttl_in_seconds: i64,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityExtensionDataArray {
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<EntityExtensionDataArrayHeader>,
    #[prost(enumeration = "ExtensionKind", tag = "2")]
    pub extension_kind: i32,
    #[prost(message, repeated, tag = "3")]
    pub extension_data: ::prost::alloc::vec::Vec<EntityExtensionData>,
}
/// empty
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchedExtensionResponseHeader {}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchedExtensionResponse {
    /// reserved
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<BatchedExtensionResponseHeader>,
    #[prost(message, repeated, tag = "2")]
    pub extended_metadata: ::prost::alloc::vec::Vec<EntityExtensionDataArray>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityExtensionDataHeader {
    /// HTTP-compliant status code
    #[prost(int32, tag = "1")]
    pub status_code: i32,
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub locale: ::prost::alloc::string::String,
    /// Per-entity cache TTLs. See EntityExtensionDataArray for details. The per-entity cache
    /// TTLs will override the default TTLs specified in the enclosing EntityExtensionDataArray
    /// message. (The override is active if the per-entity cache TTL is non-zero.)
    #[prost(int64, tag = "4")]
    pub cache_ttl_in_seconds: i64,
    #[deprecated]
    #[prost(int64, tag = "5")]
    pub offline_ttl_in_seconds: i64,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityExtensionData {
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<EntityExtensionDataHeader>,
    #[prost(string, tag = "2")]
    pub entity_uri: ::prost::alloc::string::String,
    /// <https://developers.google.com/protocol-buffers/docs/proto3#any>
    #[prost(message, optional, tag = "3")]
    pub extension_data: ::core::option::Option<super::super::google::protobuf::Any>,
}
/// Mark obsolete extension kinds as deprecated - client-core will add a comment
/// to deprecated extension kinds.
#[derive(serde::Deserialize, serde::Serialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExtensionKind {
    UnknownExtension = 0,
    Canvaz = 1,
    Storylines = 2,
    PodcastTopics = 3,
    PodcastSegments = 4,
    AudioFiles = 5,
    TrackDescriptor = 6,
    PodcastCounter = 7,
    ArtistV4 = 8,
    AlbumV4 = 9,
    TrackV4 = 10,
    ShowV4 = 11,
    EpisodeV4 = 12,
    PodcastHtmlDescription = 13,
    PodcastQuotes = 14,
    UserProfile = 15,
    CanvasV1 = 16,
    ShowV4Base = 17,
    ShowV4EpisodesAssoc = 18,
    TrackDescriptorSignatures = 19,
    PodcastAdSegments = 20,
    EpisodeTranscripts = 21,
    /// use EPISODE_ACCESS
    PodcastSubscriptions = 22,
    ExtractedColor = 23,
    PodcastVirality = 24,
    ImageSparklesHack = 25,
    PodcastPopularityHack = 26,
    AutomixMode = 27,
    Cuepoints = 28,
    PodcastPoll = 29,
    EpisodeAccess = 30,
    ShowAccess = 31,
    PodcastQna = 32,
    Clips = 33,
    ShowV5 = 34,
    EpisodeV5 = 35,
    PodcastCtaCards = 36,
    PodcastRating = 37,
    DisplaySegments = 38,
    Greenroom = 39,
    UserCreated = 40,
    ShowDescription = 41,
    ShowHtmlDescription = 42,
    ShowPlayability = 43,
    EpisodeDescription = 44,
    EpisodeHtmlDescription = 45,
    EpisodePlayability = 46,
    ShowEpisodesAssoc = 47,
    ClientConfig = 48,
    Playlistability = 49,
    AudiobookV5 = 50,
    ChapterV5 = 51,
    AudiobookSpecifics = 52,
    EpisodeRanking = 53,
    HtmlDescription = 54,
    CreatorChannel = 55,
    AudiobookProviders = 56,
    PlayTrait = 57,
    ContentWarning = 58,
    ImageCue = 59,
    StreamCount = 60,
    AudioAttributes = 61,
    NavigableTrait = 62,
    NextBestEpisode = 63,
    AudiobookPrice = 64,
    ExpressivePlaylists = 65,
    DynamicShowEpisode = 66,
    Live = 67,
    SkipPlayed = 68,
    AdBreakFreePodcasts = 69,
    Associations = 70,
    PlaylistEvaluation = 71,
    CacheInvalidations = 72,
    LivestreamEntity = 73,
    SingleTapReactions = 74,
    UserComments = 75,
    ClientRestrictions = 76,
    PodcastGuest = 77,
    Playability = 78,
    CoverImage = 79,
    ShareTrait = 80,
    InstanceSharing = 81,
    ArtistTour = 82,
    AudiobookGenre = 83,
    Concept = 84,
    OriginalVideo = 85,
    SmartShuffle = 86,
    LiveEvents = 87,
    AudiobookRelations = 88,
    HomePocBasecard = 89,
    AudiobookSupplements = 90,
    PaidPodcastBanner = 91,
    FewerAds = 92,
    WatchFeedShowExplorer = 93,
    TrackExtraDescriptors = 94,
    TrackExtraAudioAttributes = 95,
    TrackExtendedCredits = 96,
    SimpleTrait = 97,
    AudioAssociations = 98,
    VideoAssociations = 99,
    PlaylistTuner = 100,
    ArtistVideosEntrypoint = 101,
    AlbumPrerelease = 102,
    ContentAlternatives = 103,
    SnapshotSharing = 105,
    DisplaySegmentsCount = 106,
    PodcastFeaturedEpisode = 107,
    PodcastSponsoredContent = 108,
    PodcastEpisodeTopicsLlm = 109,
    PodcastEpisodeTopicsKg = 110,
    EpisodeRankingPopularity = 111,
    Merch = 112,
    CompanionContent = 113,
    WatchFeedEntityExplorer = 114,
    AnchorCardTrait = 115,
    AudioPreviewPlaybackTrait = 116,
    VideoPreviewStillTrait = 117,
    PreviewCardTrait = 118,
    ShortcutsCardTrait = 119,
    VideoPreviewPlaybackTrait = 120,
    CourseSpecifics = 121,
    Concert = 122,
    ConcertLocation = 123,
    ConcertMarketing = 124,
    ConcertPerformers = 125,
    TrackPairTransition = 126,
    ContentTypeTrait = 127,
    NameTrait = 128,
    ArtworkTrait = 129,
    ReleaseDateTrait = 130,
    CreditsTrait = 131,
    ReleaseUriTrait = 132,
    EntityCapping = 133,
    LessonSpecifics = 134,
    ConcertOffers = 135,
    TransitionMaps = 136,
    ArtistHasConcerts = 137,
    Prerelease = 138,
    PlaylistAttributesV2 = 139,
    ListAttributesV2 = 140,
    ListMetadata = 141,
    ListTunerAudioAnalysis = 142,
    ListTunerCuepoints = 143,
    ContentRatingTrait = 144,
    CopyrightTrait = 145,
    SupportedBadges = 146,
    Badges = 147,
    PreviewTrait = 148,
    RootlistabilityTrait = 149,
    LocalConcerts = 150,
    RecommendedPlaylists = 151,
    PopularReleases = 152,
    RelatedReleases = 153,
    ShareRestrictions = 154,
    ConcertOffer = 155,
    ConcertOfferProvider = 156,
    EntityBookmarks = 157,
    PrivacyTrait = 158,
    DuplicateItemsTrait = 159,
    ReorderingTrait = 160,
    PodcastResumptionSegments = 161,
    ArtistExpressionVideo = 162,
    PrereleaseVideo = 163,
    GatedEntityRelations = 164,
    RelatedCreatorsSection = 165,
    CreatorsAppearsOnSection = 166,
    PromoV1Trait = 167,
    SpeechlessShareCard = 168,
    TopPlayablesSection = 169,
    AutoLens = 170,
    PromoV3Trait = 171,
    TrackContentFilter = 172,
    Highlightability = 173,
    LinkCardWithImageTrait = 174,
    TrackCloudSection = 175,
    EpisodeTopics = 176,
    VideoThumbnail = 177,
    IdentityTrait = 178,
    VisualIdentityTrait = 179,
    ContentTypeV2Trait = 180,
    PreviewPlaybackTrait = 181,
    ConsumptionExperienceTrait = 182,
    PublishingMetadataTrait = 183,
    DetailedEvaluationTrait = 184,
    OnPlatformReputationTrait = 185,
    CreditsV2Trait = 186,
    HighlightPlayabilityTrait = 187,
    ShowEpisodeList = 188,
    AvailableReleases = 189,
    PlaylistDescriptors = 190,
    LinkCardWithAnimationsTrait = 191,
    Recap = 192,
    AudiobookCompanionContent = 193,
    ThreeOhThreePlayTrait = 194,
    ArtistWrapped2024Video = 195,
    ContainedContentTypes = 196,
    ContentClassification = 197,
    ChapterSpecifics = 198,
    CreatorFanFunding = 199,
    CreatorPlaylistsSection = 200,
    CreatorPinnedItem = 201,
    PodcastPollV2 = 202,
    CreatorAppearsOnSection = 203,
    ArtistConcerts = 204,
}
impl ExtensionKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ExtensionKind::UnknownExtension => "UNKNOWN_EXTENSION",
            ExtensionKind::Canvaz => "CANVAZ",
            ExtensionKind::Storylines => "STORYLINES",
            ExtensionKind::PodcastTopics => "PODCAST_TOPICS",
            ExtensionKind::PodcastSegments => "PODCAST_SEGMENTS",
            ExtensionKind::AudioFiles => "AUDIO_FILES",
            ExtensionKind::TrackDescriptor => "TRACK_DESCRIPTOR",
            ExtensionKind::PodcastCounter => "PODCAST_COUNTER",
            ExtensionKind::ArtistV4 => "ARTIST_V4",
            ExtensionKind::AlbumV4 => "ALBUM_V4",
            ExtensionKind::TrackV4 => "TRACK_V4",
            ExtensionKind::ShowV4 => "SHOW_V4",
            ExtensionKind::EpisodeV4 => "EPISODE_V4",
            ExtensionKind::PodcastHtmlDescription => "PODCAST_HTML_DESCRIPTION",
            ExtensionKind::PodcastQuotes => "PODCAST_QUOTES",
            ExtensionKind::UserProfile => "USER_PROFILE",
            ExtensionKind::CanvasV1 => "CANVAS_V1",
            ExtensionKind::ShowV4Base => "SHOW_V4_BASE",
            ExtensionKind::ShowV4EpisodesAssoc => "SHOW_V4_EPISODES_ASSOC",
            ExtensionKind::TrackDescriptorSignatures => "TRACK_DESCRIPTOR_SIGNATURES",
            ExtensionKind::PodcastAdSegments => "PODCAST_AD_SEGMENTS",
            ExtensionKind::EpisodeTranscripts => "EPISODE_TRANSCRIPTS",
            ExtensionKind::PodcastSubscriptions => "PODCAST_SUBSCRIPTIONS",
            ExtensionKind::ExtractedColor => "EXTRACTED_COLOR",
            ExtensionKind::PodcastVirality => "PODCAST_VIRALITY",
            ExtensionKind::ImageSparklesHack => "IMAGE_SPARKLES_HACK",
            ExtensionKind::PodcastPopularityHack => "PODCAST_POPULARITY_HACK",
            ExtensionKind::AutomixMode => "AUTOMIX_MODE",
            ExtensionKind::Cuepoints => "CUEPOINTS",
            ExtensionKind::PodcastPoll => "PODCAST_POLL",
            ExtensionKind::EpisodeAccess => "EPISODE_ACCESS",
            ExtensionKind::ShowAccess => "SHOW_ACCESS",
            ExtensionKind::PodcastQna => "PODCAST_QNA",
            ExtensionKind::Clips => "CLIPS",
            ExtensionKind::ShowV5 => "SHOW_V5",
            ExtensionKind::EpisodeV5 => "EPISODE_V5",
            ExtensionKind::PodcastCtaCards => "PODCAST_CTA_CARDS",
            ExtensionKind::PodcastRating => "PODCAST_RATING",
            ExtensionKind::DisplaySegments => "DISPLAY_SEGMENTS",
            ExtensionKind::Greenroom => "GREENROOM",
            ExtensionKind::UserCreated => "USER_CREATED",
            ExtensionKind::ShowDescription => "SHOW_DESCRIPTION",
            ExtensionKind::ShowHtmlDescription => "SHOW_HTML_DESCRIPTION",
            ExtensionKind::ShowPlayability => "SHOW_PLAYABILITY",
            ExtensionKind::EpisodeDescription => "EPISODE_DESCRIPTION",
            ExtensionKind::EpisodeHtmlDescription => "EPISODE_HTML_DESCRIPTION",
            ExtensionKind::EpisodePlayability => "EPISODE_PLAYABILITY",
            ExtensionKind::ShowEpisodesAssoc => "SHOW_EPISODES_ASSOC",
            ExtensionKind::ClientConfig => "CLIENT_CONFIG",
            ExtensionKind::Playlistability => "PLAYLISTABILITY",
            ExtensionKind::AudiobookV5 => "AUDIOBOOK_V5",
            ExtensionKind::ChapterV5 => "CHAPTER_V5",
            ExtensionKind::AudiobookSpecifics => "AUDIOBOOK_SPECIFICS",
            ExtensionKind::EpisodeRanking => "EPISODE_RANKING",
            ExtensionKind::HtmlDescription => "HTML_DESCRIPTION",
            ExtensionKind::CreatorChannel => "CREATOR_CHANNEL",
            ExtensionKind::AudiobookProviders => "AUDIOBOOK_PROVIDERS",
            ExtensionKind::PlayTrait => "PLAY_TRAIT",
            ExtensionKind::ContentWarning => "CONTENT_WARNING",
            ExtensionKind::ImageCue => "IMAGE_CUE",
            ExtensionKind::StreamCount => "STREAM_COUNT",
            ExtensionKind::AudioAttributes => "AUDIO_ATTRIBUTES",
            ExtensionKind::NavigableTrait => "NAVIGABLE_TRAIT",
            ExtensionKind::NextBestEpisode => "NEXT_BEST_EPISODE",
            ExtensionKind::AudiobookPrice => "AUDIOBOOK_PRICE",
            ExtensionKind::ExpressivePlaylists => "EXPRESSIVE_PLAYLISTS",
            ExtensionKind::DynamicShowEpisode => "DYNAMIC_SHOW_EPISODE",
            ExtensionKind::Live => "LIVE",
            ExtensionKind::SkipPlayed => "SKIP_PLAYED",
            ExtensionKind::AdBreakFreePodcasts => "AD_BREAK_FREE_PODCASTS",
            ExtensionKind::Associations => "ASSOCIATIONS",
            ExtensionKind::PlaylistEvaluation => "PLAYLIST_EVALUATION",
            ExtensionKind::CacheInvalidations => "CACHE_INVALIDATIONS",
            ExtensionKind::LivestreamEntity => "LIVESTREAM_ENTITY",
            ExtensionKind::SingleTapReactions => "SINGLE_TAP_REACTIONS",
            ExtensionKind::UserComments => "USER_COMMENTS",
            ExtensionKind::ClientRestrictions => "CLIENT_RESTRICTIONS",
            ExtensionKind::PodcastGuest => "PODCAST_GUEST",
            ExtensionKind::Playability => "PLAYABILITY",
            ExtensionKind::CoverImage => "COVER_IMAGE",
            ExtensionKind::ShareTrait => "SHARE_TRAIT",
            ExtensionKind::InstanceSharing => "INSTANCE_SHARING",
            ExtensionKind::ArtistTour => "ARTIST_TOUR",
            ExtensionKind::AudiobookGenre => "AUDIOBOOK_GENRE",
            ExtensionKind::Concept => "CONCEPT",
            ExtensionKind::OriginalVideo => "ORIGINAL_VIDEO",
            ExtensionKind::SmartShuffle => "SMART_SHUFFLE",
            ExtensionKind::LiveEvents => "LIVE_EVENTS",
            ExtensionKind::AudiobookRelations => "AUDIOBOOK_RELATIONS",
            ExtensionKind::HomePocBasecard => "HOME_POC_BASECARD",
            ExtensionKind::AudiobookSupplements => "AUDIOBOOK_SUPPLEMENTS",
            ExtensionKind::PaidPodcastBanner => "PAID_PODCAST_BANNER",
            ExtensionKind::FewerAds => "FEWER_ADS",
            ExtensionKind::WatchFeedShowExplorer => "WATCH_FEED_SHOW_EXPLORER",
            ExtensionKind::TrackExtraDescriptors => "TRACK_EXTRA_DESCRIPTORS",
            ExtensionKind::TrackExtraAudioAttributes => "TRACK_EXTRA_AUDIO_ATTRIBUTES",
            ExtensionKind::TrackExtendedCredits => "TRACK_EXTENDED_CREDITS",
            ExtensionKind::SimpleTrait => "SIMPLE_TRAIT",
            ExtensionKind::AudioAssociations => "AUDIO_ASSOCIATIONS",
            ExtensionKind::VideoAssociations => "VIDEO_ASSOCIATIONS",
            ExtensionKind::PlaylistTuner => "PLAYLIST_TUNER",
            ExtensionKind::ArtistVideosEntrypoint => "ARTIST_VIDEOS_ENTRYPOINT",
            ExtensionKind::AlbumPrerelease => "ALBUM_PRERELEASE",
            ExtensionKind::ContentAlternatives => "CONTENT_ALTERNATIVES",
            ExtensionKind::SnapshotSharing => "SNAPSHOT_SHARING",
            ExtensionKind::DisplaySegmentsCount => "DISPLAY_SEGMENTS_COUNT",
            ExtensionKind::PodcastFeaturedEpisode => "PODCAST_FEATURED_EPISODE",
            ExtensionKind::PodcastSponsoredContent => "PODCAST_SPONSORED_CONTENT",
            ExtensionKind::PodcastEpisodeTopicsLlm => "PODCAST_EPISODE_TOPICS_LLM",
            ExtensionKind::PodcastEpisodeTopicsKg => "PODCAST_EPISODE_TOPICS_KG",
            ExtensionKind::EpisodeRankingPopularity => "EPISODE_RANKING_POPULARITY",
            ExtensionKind::Merch => "MERCH",
            ExtensionKind::CompanionContent => "COMPANION_CONTENT",
            ExtensionKind::WatchFeedEntityExplorer => "WATCH_FEED_ENTITY_EXPLORER",
            ExtensionKind::AnchorCardTrait => "ANCHOR_CARD_TRAIT",
            ExtensionKind::AudioPreviewPlaybackTrait => "AUDIO_PREVIEW_PLAYBACK_TRAIT",
            ExtensionKind::VideoPreviewStillTrait => "VIDEO_PREVIEW_STILL_TRAIT",
            ExtensionKind::PreviewCardTrait => "PREVIEW_CARD_TRAIT",
            ExtensionKind::ShortcutsCardTrait => "SHORTCUTS_CARD_TRAIT",
            ExtensionKind::VideoPreviewPlaybackTrait => "VIDEO_PREVIEW_PLAYBACK_TRAIT",
            ExtensionKind::CourseSpecifics => "COURSE_SPECIFICS",
            ExtensionKind::Concert => "CONCERT",
            ExtensionKind::ConcertLocation => "CONCERT_LOCATION",
            ExtensionKind::ConcertMarketing => "CONCERT_MARKETING",
            ExtensionKind::ConcertPerformers => "CONCERT_PERFORMERS",
            ExtensionKind::TrackPairTransition => "TRACK_PAIR_TRANSITION",
            ExtensionKind::ContentTypeTrait => "CONTENT_TYPE_TRAIT",
            ExtensionKind::NameTrait => "NAME_TRAIT",
            ExtensionKind::ArtworkTrait => "ARTWORK_TRAIT",
            ExtensionKind::ReleaseDateTrait => "RELEASE_DATE_TRAIT",
            ExtensionKind::CreditsTrait => "CREDITS_TRAIT",
            ExtensionKind::ReleaseUriTrait => "RELEASE_URI_TRAIT",
            ExtensionKind::EntityCapping => "ENTITY_CAPPING",
            ExtensionKind::LessonSpecifics => "LESSON_SPECIFICS",
            ExtensionKind::ConcertOffers => "CONCERT_OFFERS",
            ExtensionKind::TransitionMaps => "TRANSITION_MAPS",
            ExtensionKind::ArtistHasConcerts => "ARTIST_HAS_CONCERTS",
            ExtensionKind::Prerelease => "PRERELEASE",
            ExtensionKind::PlaylistAttributesV2 => "PLAYLIST_ATTRIBUTES_V2",
            ExtensionKind::ListAttributesV2 => "LIST_ATTRIBUTES_V2",
            ExtensionKind::ListMetadata => "LIST_METADATA",
            ExtensionKind::ListTunerAudioAnalysis => "LIST_TUNER_AUDIO_ANALYSIS",
            ExtensionKind::ListTunerCuepoints => "LIST_TUNER_CUEPOINTS",
            ExtensionKind::ContentRatingTrait => "CONTENT_RATING_TRAIT",
            ExtensionKind::CopyrightTrait => "COPYRIGHT_TRAIT",
            ExtensionKind::SupportedBadges => "SUPPORTED_BADGES",
            ExtensionKind::Badges => "BADGES",
            ExtensionKind::PreviewTrait => "PREVIEW_TRAIT",
            ExtensionKind::RootlistabilityTrait => "ROOTLISTABILITY_TRAIT",
            ExtensionKind::LocalConcerts => "LOCAL_CONCERTS",
            ExtensionKind::RecommendedPlaylists => "RECOMMENDED_PLAYLISTS",
            ExtensionKind::PopularReleases => "POPULAR_RELEASES",
            ExtensionKind::RelatedReleases => "RELATED_RELEASES",
            ExtensionKind::ShareRestrictions => "SHARE_RESTRICTIONS",
            ExtensionKind::ConcertOffer => "CONCERT_OFFER",
            ExtensionKind::ConcertOfferProvider => "CONCERT_OFFER_PROVIDER",
            ExtensionKind::EntityBookmarks => "ENTITY_BOOKMARKS",
            ExtensionKind::PrivacyTrait => "PRIVACY_TRAIT",
            ExtensionKind::DuplicateItemsTrait => "DUPLICATE_ITEMS_TRAIT",
            ExtensionKind::ReorderingTrait => "REORDERING_TRAIT",
            ExtensionKind::PodcastResumptionSegments => "PODCAST_RESUMPTION_SEGMENTS",
            ExtensionKind::ArtistExpressionVideo => "ARTIST_EXPRESSION_VIDEO",
            ExtensionKind::PrereleaseVideo => "PRERELEASE_VIDEO",
            ExtensionKind::GatedEntityRelations => "GATED_ENTITY_RELATIONS",
            ExtensionKind::RelatedCreatorsSection => "RELATED_CREATORS_SECTION",
            ExtensionKind::CreatorsAppearsOnSection => "CREATORS_APPEARS_ON_SECTION",
            ExtensionKind::PromoV1Trait => "PROMO_V1_TRAIT",
            ExtensionKind::SpeechlessShareCard => "SPEECHLESS_SHARE_CARD",
            ExtensionKind::TopPlayablesSection => "TOP_PLAYABLES_SECTION",
            ExtensionKind::AutoLens => "AUTO_LENS",
            ExtensionKind::PromoV3Trait => "PROMO_V3_TRAIT",
            ExtensionKind::TrackContentFilter => "TRACK_CONTENT_FILTER",
            ExtensionKind::Highlightability => "HIGHLIGHTABILITY",
            ExtensionKind::LinkCardWithImageTrait => "LINK_CARD_WITH_IMAGE_TRAIT",
            ExtensionKind::TrackCloudSection => "TRACK_CLOUD_SECTION",
            ExtensionKind::EpisodeTopics => "EPISODE_TOPICS",
            ExtensionKind::VideoThumbnail => "VIDEO_THUMBNAIL",
            ExtensionKind::IdentityTrait => "IDENTITY_TRAIT",
            ExtensionKind::VisualIdentityTrait => "VISUAL_IDENTITY_TRAIT",
            ExtensionKind::ContentTypeV2Trait => "CONTENT_TYPE_V2_TRAIT",
            ExtensionKind::PreviewPlaybackTrait => "PREVIEW_PLAYBACK_TRAIT",
            ExtensionKind::ConsumptionExperienceTrait => "CONSUMPTION_EXPERIENCE_TRAIT",
            ExtensionKind::PublishingMetadataTrait => "PUBLISHING_METADATA_TRAIT",
            ExtensionKind::DetailedEvaluationTrait => "DETAILED_EVALUATION_TRAIT",
            ExtensionKind::OnPlatformReputationTrait => "ON_PLATFORM_REPUTATION_TRAIT",
            ExtensionKind::CreditsV2Trait => "CREDITS_V2_TRAIT",
            ExtensionKind::HighlightPlayabilityTrait => "HIGHLIGHT_PLAYABILITY_TRAIT",
            ExtensionKind::ShowEpisodeList => "SHOW_EPISODE_LIST",
            ExtensionKind::AvailableReleases => "AVAILABLE_RELEASES",
            ExtensionKind::PlaylistDescriptors => "PLAYLIST_DESCRIPTORS",
            ExtensionKind::LinkCardWithAnimationsTrait => {
                "LINK_CARD_WITH_ANIMATIONS_TRAIT"
            }
            ExtensionKind::Recap => "RECAP",
            ExtensionKind::AudiobookCompanionContent => "AUDIOBOOK_COMPANION_CONTENT",
            ExtensionKind::ThreeOhThreePlayTrait => "THREE_OH_THREE_PLAY_TRAIT",
            ExtensionKind::ArtistWrapped2024Video => "ARTIST_WRAPPED_2024_VIDEO",
            ExtensionKind::ContainedContentTypes => "CONTAINED_CONTENT_TYPES",
            ExtensionKind::ContentClassification => "CONTENT_CLASSIFICATION",
            ExtensionKind::ChapterSpecifics => "CHAPTER_SPECIFICS",
            ExtensionKind::CreatorFanFunding => "CREATOR_FAN_FUNDING",
            ExtensionKind::CreatorPlaylistsSection => "CREATOR_PLAYLISTS_SECTION",
            ExtensionKind::CreatorPinnedItem => "CREATOR_PINNED_ITEM",
            ExtensionKind::PodcastPollV2 => "PODCAST_POLL_V2",
            ExtensionKind::CreatorAppearsOnSection => "CREATOR_APPEARS_ON_SECTION",
            ExtensionKind::ArtistConcerts => "ARTIST_CONCERTS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_EXTENSION" => Some(Self::UnknownExtension),
            "CANVAZ" => Some(Self::Canvaz),
            "STORYLINES" => Some(Self::Storylines),
            "PODCAST_TOPICS" => Some(Self::PodcastTopics),
            "PODCAST_SEGMENTS" => Some(Self::PodcastSegments),
            "AUDIO_FILES" => Some(Self::AudioFiles),
            "TRACK_DESCRIPTOR" => Some(Self::TrackDescriptor),
            "PODCAST_COUNTER" => Some(Self::PodcastCounter),
            "ARTIST_V4" => Some(Self::ArtistV4),
            "ALBUM_V4" => Some(Self::AlbumV4),
            "TRACK_V4" => Some(Self::TrackV4),
            "SHOW_V4" => Some(Self::ShowV4),
            "EPISODE_V4" => Some(Self::EpisodeV4),
            "PODCAST_HTML_DESCRIPTION" => Some(Self::PodcastHtmlDescription),
            "PODCAST_QUOTES" => Some(Self::PodcastQuotes),
            "USER_PROFILE" => Some(Self::UserProfile),
            "CANVAS_V1" => Some(Self::CanvasV1),
            "SHOW_V4_BASE" => Some(Self::ShowV4Base),
            "SHOW_V4_EPISODES_ASSOC" => Some(Self::ShowV4EpisodesAssoc),
            "TRACK_DESCRIPTOR_SIGNATURES" => Some(Self::TrackDescriptorSignatures),
            "PODCAST_AD_SEGMENTS" => Some(Self::PodcastAdSegments),
            "EPISODE_TRANSCRIPTS" => Some(Self::EpisodeTranscripts),
            "PODCAST_SUBSCRIPTIONS" => Some(Self::PodcastSubscriptions),
            "EXTRACTED_COLOR" => Some(Self::ExtractedColor),
            "PODCAST_VIRALITY" => Some(Self::PodcastVirality),
            "IMAGE_SPARKLES_HACK" => Some(Self::ImageSparklesHack),
            "PODCAST_POPULARITY_HACK" => Some(Self::PodcastPopularityHack),
            "AUTOMIX_MODE" => Some(Self::AutomixMode),
            "CUEPOINTS" => Some(Self::Cuepoints),
            "PODCAST_POLL" => Some(Self::PodcastPoll),
            "EPISODE_ACCESS" => Some(Self::EpisodeAccess),
            "SHOW_ACCESS" => Some(Self::ShowAccess),
            "PODCAST_QNA" => Some(Self::PodcastQna),
            "CLIPS" => Some(Self::Clips),
            "SHOW_V5" => Some(Self::ShowV5),
            "EPISODE_V5" => Some(Self::EpisodeV5),
            "PODCAST_CTA_CARDS" => Some(Self::PodcastCtaCards),
            "PODCAST_RATING" => Some(Self::PodcastRating),
            "DISPLAY_SEGMENTS" => Some(Self::DisplaySegments),
            "GREENROOM" => Some(Self::Greenroom),
            "USER_CREATED" => Some(Self::UserCreated),
            "SHOW_DESCRIPTION" => Some(Self::ShowDescription),
            "SHOW_HTML_DESCRIPTION" => Some(Self::ShowHtmlDescription),
            "SHOW_PLAYABILITY" => Some(Self::ShowPlayability),
            "EPISODE_DESCRIPTION" => Some(Self::EpisodeDescription),
            "EPISODE_HTML_DESCRIPTION" => Some(Self::EpisodeHtmlDescription),
            "EPISODE_PLAYABILITY" => Some(Self::EpisodePlayability),
            "SHOW_EPISODES_ASSOC" => Some(Self::ShowEpisodesAssoc),
            "CLIENT_CONFIG" => Some(Self::ClientConfig),
            "PLAYLISTABILITY" => Some(Self::Playlistability),
            "AUDIOBOOK_V5" => Some(Self::AudiobookV5),
            "CHAPTER_V5" => Some(Self::ChapterV5),
            "AUDIOBOOK_SPECIFICS" => Some(Self::AudiobookSpecifics),
            "EPISODE_RANKING" => Some(Self::EpisodeRanking),
            "HTML_DESCRIPTION" => Some(Self::HtmlDescription),
            "CREATOR_CHANNEL" => Some(Self::CreatorChannel),
            "AUDIOBOOK_PROVIDERS" => Some(Self::AudiobookProviders),
            "PLAY_TRAIT" => Some(Self::PlayTrait),
            "CONTENT_WARNING" => Some(Self::ContentWarning),
            "IMAGE_CUE" => Some(Self::ImageCue),
            "STREAM_COUNT" => Some(Self::StreamCount),
            "AUDIO_ATTRIBUTES" => Some(Self::AudioAttributes),
            "NAVIGABLE_TRAIT" => Some(Self::NavigableTrait),
            "NEXT_BEST_EPISODE" => Some(Self::NextBestEpisode),
            "AUDIOBOOK_PRICE" => Some(Self::AudiobookPrice),
            "EXPRESSIVE_PLAYLISTS" => Some(Self::ExpressivePlaylists),
            "DYNAMIC_SHOW_EPISODE" => Some(Self::DynamicShowEpisode),
            "LIVE" => Some(Self::Live),
            "SKIP_PLAYED" => Some(Self::SkipPlayed),
            "AD_BREAK_FREE_PODCASTS" => Some(Self::AdBreakFreePodcasts),
            "ASSOCIATIONS" => Some(Self::Associations),
            "PLAYLIST_EVALUATION" => Some(Self::PlaylistEvaluation),
            "CACHE_INVALIDATIONS" => Some(Self::CacheInvalidations),
            "LIVESTREAM_ENTITY" => Some(Self::LivestreamEntity),
            "SINGLE_TAP_REACTIONS" => Some(Self::SingleTapReactions),
            "USER_COMMENTS" => Some(Self::UserComments),
            "CLIENT_RESTRICTIONS" => Some(Self::ClientRestrictions),
            "PODCAST_GUEST" => Some(Self::PodcastGuest),
            "PLAYABILITY" => Some(Self::Playability),
            "COVER_IMAGE" => Some(Self::CoverImage),
            "SHARE_TRAIT" => Some(Self::ShareTrait),
            "INSTANCE_SHARING" => Some(Self::InstanceSharing),
            "ARTIST_TOUR" => Some(Self::ArtistTour),
            "AUDIOBOOK_GENRE" => Some(Self::AudiobookGenre),
            "CONCEPT" => Some(Self::Concept),
            "ORIGINAL_VIDEO" => Some(Self::OriginalVideo),
            "SMART_SHUFFLE" => Some(Self::SmartShuffle),
            "LIVE_EVENTS" => Some(Self::LiveEvents),
            "AUDIOBOOK_RELATIONS" => Some(Self::AudiobookRelations),
            "HOME_POC_BASECARD" => Some(Self::HomePocBasecard),
            "AUDIOBOOK_SUPPLEMENTS" => Some(Self::AudiobookSupplements),
            "PAID_PODCAST_BANNER" => Some(Self::PaidPodcastBanner),
            "FEWER_ADS" => Some(Self::FewerAds),
            "WATCH_FEED_SHOW_EXPLORER" => Some(Self::WatchFeedShowExplorer),
            "TRACK_EXTRA_DESCRIPTORS" => Some(Self::TrackExtraDescriptors),
            "TRACK_EXTRA_AUDIO_ATTRIBUTES" => Some(Self::TrackExtraAudioAttributes),
            "TRACK_EXTENDED_CREDITS" => Some(Self::TrackExtendedCredits),
            "SIMPLE_TRAIT" => Some(Self::SimpleTrait),
            "AUDIO_ASSOCIATIONS" => Some(Self::AudioAssociations),
            "VIDEO_ASSOCIATIONS" => Some(Self::VideoAssociations),
            "PLAYLIST_TUNER" => Some(Self::PlaylistTuner),
            "ARTIST_VIDEOS_ENTRYPOINT" => Some(Self::ArtistVideosEntrypoint),
            "ALBUM_PRERELEASE" => Some(Self::AlbumPrerelease),
            "CONTENT_ALTERNATIVES" => Some(Self::ContentAlternatives),
            "SNAPSHOT_SHARING" => Some(Self::SnapshotSharing),
            "DISPLAY_SEGMENTS_COUNT" => Some(Self::DisplaySegmentsCount),
            "PODCAST_FEATURED_EPISODE" => Some(Self::PodcastFeaturedEpisode),
            "PODCAST_SPONSORED_CONTENT" => Some(Self::PodcastSponsoredContent),
            "PODCAST_EPISODE_TOPICS_LLM" => Some(Self::PodcastEpisodeTopicsLlm),
            "PODCAST_EPISODE_TOPICS_KG" => Some(Self::PodcastEpisodeTopicsKg),
            "EPISODE_RANKING_POPULARITY" => Some(Self::EpisodeRankingPopularity),
            "MERCH" => Some(Self::Merch),
            "COMPANION_CONTENT" => Some(Self::CompanionContent),
            "WATCH_FEED_ENTITY_EXPLORER" => Some(Self::WatchFeedEntityExplorer),
            "ANCHOR_CARD_TRAIT" => Some(Self::AnchorCardTrait),
            "AUDIO_PREVIEW_PLAYBACK_TRAIT" => Some(Self::AudioPreviewPlaybackTrait),
            "VIDEO_PREVIEW_STILL_TRAIT" => Some(Self::VideoPreviewStillTrait),
            "PREVIEW_CARD_TRAIT" => Some(Self::PreviewCardTrait),
            "SHORTCUTS_CARD_TRAIT" => Some(Self::ShortcutsCardTrait),
            "VIDEO_PREVIEW_PLAYBACK_TRAIT" => Some(Self::VideoPreviewPlaybackTrait),
            "COURSE_SPECIFICS" => Some(Self::CourseSpecifics),
            "CONCERT" => Some(Self::Concert),
            "CONCERT_LOCATION" => Some(Self::ConcertLocation),
            "CONCERT_MARKETING" => Some(Self::ConcertMarketing),
            "CONCERT_PERFORMERS" => Some(Self::ConcertPerformers),
            "TRACK_PAIR_TRANSITION" => Some(Self::TrackPairTransition),
            "CONTENT_TYPE_TRAIT" => Some(Self::ContentTypeTrait),
            "NAME_TRAIT" => Some(Self::NameTrait),
            "ARTWORK_TRAIT" => Some(Self::ArtworkTrait),
            "RELEASE_DATE_TRAIT" => Some(Self::ReleaseDateTrait),
            "CREDITS_TRAIT" => Some(Self::CreditsTrait),
            "RELEASE_URI_TRAIT" => Some(Self::ReleaseUriTrait),
            "ENTITY_CAPPING" => Some(Self::EntityCapping),
            "LESSON_SPECIFICS" => Some(Self::LessonSpecifics),
            "CONCERT_OFFERS" => Some(Self::ConcertOffers),
            "TRANSITION_MAPS" => Some(Self::TransitionMaps),
            "ARTIST_HAS_CONCERTS" => Some(Self::ArtistHasConcerts),
            "PRERELEASE" => Some(Self::Prerelease),
            "PLAYLIST_ATTRIBUTES_V2" => Some(Self::PlaylistAttributesV2),
            "LIST_ATTRIBUTES_V2" => Some(Self::ListAttributesV2),
            "LIST_METADATA" => Some(Self::ListMetadata),
            "LIST_TUNER_AUDIO_ANALYSIS" => Some(Self::ListTunerAudioAnalysis),
            "LIST_TUNER_CUEPOINTS" => Some(Self::ListTunerCuepoints),
            "CONTENT_RATING_TRAIT" => Some(Self::ContentRatingTrait),
            "COPYRIGHT_TRAIT" => Some(Self::CopyrightTrait),
            "SUPPORTED_BADGES" => Some(Self::SupportedBadges),
            "BADGES" => Some(Self::Badges),
            "PREVIEW_TRAIT" => Some(Self::PreviewTrait),
            "ROOTLISTABILITY_TRAIT" => Some(Self::RootlistabilityTrait),
            "LOCAL_CONCERTS" => Some(Self::LocalConcerts),
            "RECOMMENDED_PLAYLISTS" => Some(Self::RecommendedPlaylists),
            "POPULAR_RELEASES" => Some(Self::PopularReleases),
            "RELATED_RELEASES" => Some(Self::RelatedReleases),
            "SHARE_RESTRICTIONS" => Some(Self::ShareRestrictions),
            "CONCERT_OFFER" => Some(Self::ConcertOffer),
            "CONCERT_OFFER_PROVIDER" => Some(Self::ConcertOfferProvider),
            "ENTITY_BOOKMARKS" => Some(Self::EntityBookmarks),
            "PRIVACY_TRAIT" => Some(Self::PrivacyTrait),
            "DUPLICATE_ITEMS_TRAIT" => Some(Self::DuplicateItemsTrait),
            "REORDERING_TRAIT" => Some(Self::ReorderingTrait),
            "PODCAST_RESUMPTION_SEGMENTS" => Some(Self::PodcastResumptionSegments),
            "ARTIST_EXPRESSION_VIDEO" => Some(Self::ArtistExpressionVideo),
            "PRERELEASE_VIDEO" => Some(Self::PrereleaseVideo),
            "GATED_ENTITY_RELATIONS" => Some(Self::GatedEntityRelations),
            "RELATED_CREATORS_SECTION" => Some(Self::RelatedCreatorsSection),
            "CREATORS_APPEARS_ON_SECTION" => Some(Self::CreatorsAppearsOnSection),
            "PROMO_V1_TRAIT" => Some(Self::PromoV1Trait),
            "SPEECHLESS_SHARE_CARD" => Some(Self::SpeechlessShareCard),
            "TOP_PLAYABLES_SECTION" => Some(Self::TopPlayablesSection),
            "AUTO_LENS" => Some(Self::AutoLens),
            "PROMO_V3_TRAIT" => Some(Self::PromoV3Trait),
            "TRACK_CONTENT_FILTER" => Some(Self::TrackContentFilter),
            "HIGHLIGHTABILITY" => Some(Self::Highlightability),
            "LINK_CARD_WITH_IMAGE_TRAIT" => Some(Self::LinkCardWithImageTrait),
            "TRACK_CLOUD_SECTION" => Some(Self::TrackCloudSection),
            "EPISODE_TOPICS" => Some(Self::EpisodeTopics),
            "VIDEO_THUMBNAIL" => Some(Self::VideoThumbnail),
            "IDENTITY_TRAIT" => Some(Self::IdentityTrait),
            "VISUAL_IDENTITY_TRAIT" => Some(Self::VisualIdentityTrait),
            "CONTENT_TYPE_V2_TRAIT" => Some(Self::ContentTypeV2Trait),
            "PREVIEW_PLAYBACK_TRAIT" => Some(Self::PreviewPlaybackTrait),
            "CONSUMPTION_EXPERIENCE_TRAIT" => Some(Self::ConsumptionExperienceTrait),
            "PUBLISHING_METADATA_TRAIT" => Some(Self::PublishingMetadataTrait),
            "DETAILED_EVALUATION_TRAIT" => Some(Self::DetailedEvaluationTrait),
            "ON_PLATFORM_REPUTATION_TRAIT" => Some(Self::OnPlatformReputationTrait),
            "CREDITS_V2_TRAIT" => Some(Self::CreditsV2Trait),
            "HIGHLIGHT_PLAYABILITY_TRAIT" => Some(Self::HighlightPlayabilityTrait),
            "SHOW_EPISODE_LIST" => Some(Self::ShowEpisodeList),
            "AVAILABLE_RELEASES" => Some(Self::AvailableReleases),
            "PLAYLIST_DESCRIPTORS" => Some(Self::PlaylistDescriptors),
            "LINK_CARD_WITH_ANIMATIONS_TRAIT" => Some(Self::LinkCardWithAnimationsTrait),
            "RECAP" => Some(Self::Recap),
            "AUDIOBOOK_COMPANION_CONTENT" => Some(Self::AudiobookCompanionContent),
            "THREE_OH_THREE_PLAY_TRAIT" => Some(Self::ThreeOhThreePlayTrait),
            "ARTIST_WRAPPED_2024_VIDEO" => Some(Self::ArtistWrapped2024Video),
            "CONTAINED_CONTENT_TYPES" => Some(Self::ContainedContentTypes),
            "CONTENT_CLASSIFICATION" => Some(Self::ContentClassification),
            "CHAPTER_SPECIFICS" => Some(Self::ChapterSpecifics),
            "CREATOR_FAN_FUNDING" => Some(Self::CreatorFanFunding),
            "CREATOR_PLAYLISTS_SECTION" => Some(Self::CreatorPlaylistsSection),
            "CREATOR_PINNED_ITEM" => Some(Self::CreatorPinnedItem),
            "PODCAST_POLL_V2" => Some(Self::PodcastPollV2),
            "CREATOR_APPEARS_ON_SECTION" => Some(Self::CreatorAppearsOnSection),
            "ARTIST_CONCERTS" => Some(Self::ArtistConcerts),
            _ => None,
        }
    }
}
